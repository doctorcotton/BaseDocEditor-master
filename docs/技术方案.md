# æŠ€æœ¯æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
- [æŠ€æœ¯æ¶æ„](#æŠ€æœ¯æ¶æ„)
- [æ ¸å¿ƒæ¨¡å—è®¾è®¡](#æ ¸å¿ƒæ¨¡å—è®¾è®¡)
- [æ•°æ®æµè®¾è®¡](#æ•°æ®æµè®¾è®¡)
- [æŠ€æœ¯é€‰å‹](#æŠ€æœ¯é€‰å‹)
- [å…³é”®æŠ€æœ¯å®ç°](#å…³é”®æŠ€æœ¯å®ç°)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å®‰å…¨æ–¹æ¡ˆ](#å®‰å…¨æ–¹æ¡ˆ)

---

## æŠ€æœ¯æ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   é£ä¹¦å¤šç»´è¡¨æ ¼                        â”‚
â”‚              (æ•°æ®æº & æ•°æ®ç›®æ ‡)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ Base JS SDK
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BaseDocEditor æ’ä»¶                      â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚         æ•°æ®ç®¡ç†å±‚ (Data Layer)            â”‚    â”‚
â”‚  â”‚  â€¢ useTableData: è¯»å–è¡¨æ ¼æ•°æ®              â”‚    â”‚
â”‚  â”‚  â€¢ useFieldMeta: å­—æ®µå…ƒæ•°æ®ç®¡ç†            â”‚    â”‚
â”‚  â”‚  â€¢ useRecordCache: è®°å½•ç¼“å­˜                â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                      â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚       ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)          â”‚    â”‚
â”‚  â”‚  â€¢ useChangeTracking: ä¿®æ”¹è¿½è¸ª             â”‚    â”‚
â”‚  â”‚  â€¢ useDocumentSync: åŒæ­¥ç®¡ç†               â”‚    â”‚
â”‚  â”‚  â€¢ useCommentSystem: è¯„è®ºç³»ç»Ÿ              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                      â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚         UI å±•ç¤ºå±‚ (UI Layer)               â”‚    â”‚
â”‚  â”‚  â€¢ DocumentRenderer: æ–‡æ¡£æ¸²æŸ“              â”‚    â”‚
â”‚  â”‚  â€¢ RichTextEditor: å¯Œæ–‡æœ¬ç¼–è¾‘å™¨            â”‚    â”‚
â”‚  â”‚  â€¢ CommentPanel: è¯„è®ºé¢æ¿                  â”‚    â”‚
â”‚  â”‚  â€¢ SyncPanel: åŒæ­¥é¢æ¿                     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  æœ¬åœ°å­˜å‚¨      â”‚
            â”‚  (è¯„è®º/è‰ç¨¿)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ

```typescript
{
  "å‰ç«¯æ¡†æ¶": "React 18 + TypeScript",
  "SDK": "@lark-base-open/js-sdk",
  "UIç»„ä»¶": "@douyinfe/semi-ui",
  "å¯Œæ–‡æœ¬ç¼–è¾‘": "quill æˆ– slate",
  "çŠ¶æ€ç®¡ç†": "React Hooks + Context",
  "æ ·å¼æ–¹æ¡ˆ": "CSS Modules / styled-components",
  "æ„å»ºå·¥å…·": "Vite",
  "å›½é™…åŒ–": "react-i18next",
  "å·¥å…·åº“": "lodash-es, dayjs"
}
```

## æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. æ•°æ®ç®¡ç†å±‚

#### useTableData Hook

```typescript
/**
 * å¤šç»´è¡¨æ ¼æ•°æ®ç®¡ç†
 */
export function useTableData(tableId: string) {
  const [records, setRecords] = useState<IRecord[]>([]);
  const [fields, setFields] = useState<IFieldMeta[]>([]);
  const [loading, setLoading] = useState(false);
  
  // åŠ è½½è¡¨æ ¼æ•°æ®
  const loadData = async () => {
    setLoading(true);
    try {
      const table = await bitable.base.getTable(tableId);
      const fieldList = await table.getFieldMetaList();
      const recordList = await table.getRecords({ pageSize: 5000 });
      
      setFields(fieldList);
      setRecords(recordList.records);
    } catch (error) {
      console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // ç›‘å¬æ•°æ®å˜åŒ–
  useEffect(() => {
    if (!tableId) return;
    
    loadData();
    
    // ç›‘å¬è®°å½•å˜åŒ–
    const unsubscribe = bitable.base.onRecordAdd(() => {
      loadData();
    });
    
    return () => unsubscribe();
  }, [tableId]);
  
  return { records, fields, loading, reload: loadData };
}
```

#### useFieldMeta Hook

```typescript
/**
 * å­—æ®µå…ƒæ•°æ®ç®¡ç†
 */
export function useFieldMeta(tableId: string) {
  const [fieldMap, setFieldMap] = useState<Map<string, IFieldMeta>>(new Map());
  
  // è·å–å­—æ®µç±»å‹
  const getFieldType = (fieldId: string): FieldType | null => {
    return fieldMap.get(fieldId)?.type || null;
  };
  
  // åˆ¤æ–­å­—æ®µæ˜¯å¦å¯ç¼–è¾‘
  const isFieldEditable = (fieldId: string): boolean => {
    const type = getFieldType(fieldId);
    const nonEditableTypes = [
      FieldType.Formula,
      FieldType.Lookup,
      FieldType.AutoNumber,
      FieldType.CreatedTime,
      FieldType.CreatedUser,
      FieldType.ModifiedTime,
      FieldType.ModifiedUser,
    ];
    return type ? !nonEditableTypes.includes(type) : false;
  };
  
  return { fieldMap, getFieldType, isFieldEditable };
}
```

### 2. ä¸šåŠ¡é€»è¾‘å±‚

#### useChangeTracking Hook

```typescript
/**
 * ä¿®æ”¹è¿½è¸ªç³»ç»Ÿ
 */
interface FieldChange {
  recordId: string;
  fieldId: string;
  oldValue: any;
  newValue: any;
  timestamp: number;
  status: 'pending' | 'synced' | 'failed';
}

export function useChangeTracking() {
  const [changes, setChanges] = useState<Map<string, FieldChange>>(new Map());
  
  // è®°å½•å˜æ›´
  const trackChange = (recordId: string, fieldId: string, oldValue: any, newValue: any) => {
    const key = `${recordId}:${fieldId}`;
    
    setChanges(prev => {
      const newChanges = new Map(prev);
      newChanges.set(key, {
        recordId,
        fieldId,
        oldValue,
        newValue,
        timestamp: Date.now(),
        status: 'pending'
      });
      return newChanges;
    });
    
    // è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆè‰ç¨¿åŠŸèƒ½ï¼‰
    saveDraft(key, { recordId, fieldId, newValue });
  };
  
  // æ’¤é”€æ›´æ”¹
  const undoChange = (key: string) => {
    setChanges(prev => {
      const newChanges = new Map(prev);
      newChanges.delete(key);
      return newChanges;
    });
    removeDraft(key);
  };
  
  // è·å–æ‰€æœ‰å¾…åŒæ­¥çš„æ›´æ”¹
  const getPendingChanges = (): FieldChange[] => {
    return Array.from(changes.values()).filter(c => c.status === 'pending');
  };
  
  // æ ‡è®°ä¸ºå·²åŒæ­¥
  const markAsSynced = (key: string) => {
    setChanges(prev => {
      const newChanges = new Map(prev);
      const change = newChanges.get(key);
      if (change) {
        change.status = 'synced';
        newChanges.set(key, change);
      }
      return newChanges;
    });
  };
  
  return {
    changes,
    trackChange,
    undoChange,
    getPendingChanges,
    markAsSynced,
    changeCount: changes.size
  };
}
```

#### useDocumentSync Hook

```typescript
/**
 * æ–‡æ¡£åŒæ­¥ç®¡ç†
 */
export function useDocumentSync(tableId: string) {
  const [syncing, setSyncing] = useState(false);
  const [syncResult, setSyncResult] = useState<SyncResult | null>(null);
  
  /**
   * åŒæ­¥å˜æ›´åˆ°å¤šç»´è¡¨æ ¼
   */
  const syncChanges = async (changes: FieldChange[]) => {
    setSyncing(true);
    
    try {
      const table = await bitable.base.getTable(tableId);
      
      // æŒ‰è®°å½•åˆ†ç»„
      const recordChanges = new Map<string, Record<string, any>>();
      
      for (const change of changes) {
        if (!recordChanges.has(change.recordId)) {
          recordChanges.set(change.recordId, {});
        }
        recordChanges.get(change.recordId)![change.fieldId] = change.newValue;
      }
      
      // æ‰¹é‡æ›´æ–°è®°å½•
      const updates = Array.from(recordChanges.entries()).map(([recordId, fields]) => ({
        recordId,
        fields
      }));
      
      await table.setRecords(updates);
      
      setSyncResult({
        success: true,
        count: updates.length,
        timestamp: Date.now()
      });
      
      return true;
    } catch (error: any) {
      setSyncResult({
        success: false,
        error: error.message,
        timestamp: Date.now()
      });
      return false;
    } finally {
      setSyncing(false);
    }
  };
  
  return { syncChanges, syncing, syncResult };
}
```

#### useCommentSystem Hook

```typescript
/**
 * è¯„è®ºç³»ç»Ÿ
 */
interface Comment {
  id: string;
  recordId: string;
  fieldId: string;
  content: string;
  author: string;
  authorId: string;
  timestamp: number;
  resolved: boolean;
  parentId?: string; // å›å¤çš„è¯„è®ºID
}

export function useCommentSystem(tableId: string) {
  const [comments, setComments] = useState<Map<string, Comment[]>>(new Map());
  
  // æ·»åŠ è¯„è®º
  const addComment = async (recordId: string, fieldId: string, content: string) => {
    const key = `${recordId}:${fieldId}`;
    
    // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
    const user = await bitable.bridge.getUserInfo();
    
    const newComment: Comment = {
      id: generateId(),
      recordId,
      fieldId,
      content,
      author: user.name || 'åŒ¿åç”¨æˆ·',
      authorId: user.userId || '',
      timestamp: Date.now(),
      resolved: false
    };
    
    setComments(prev => {
      const newComments = new Map(prev);
      const fieldComments = newComments.get(key) || [];
      newComments.set(key, [...fieldComments, newComment]);
      return newComments;
    });
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    saveCommentToStorage(tableId, newComment);
  };
  
  // å›å¤è¯„è®º
  const replyComment = async (parentComment: Comment, content: string) => {
    const key = `${parentComment.recordId}:${parentComment.fieldId}`;
    const user = await bitable.bridge.getUserInfo();
    
    const reply: Comment = {
      id: generateId(),
      recordId: parentComment.recordId,
      fieldId: parentComment.fieldId,
      content,
      author: user.name || 'åŒ¿åç”¨æˆ·',
      authorId: user.userId || '',
      timestamp: Date.now(),
      resolved: false,
      parentId: parentComment.id
    };
    
    setComments(prev => {
      const newComments = new Map(prev);
      const fieldComments = newComments.get(key) || [];
      newComments.set(key, [...fieldComments, reply]);
      return newComments;
    });
    
    saveCommentToStorage(tableId, reply);
  };
  
  // æ ‡è®°è¯„è®ºä¸ºå·²è§£å†³
  const resolveComment = (commentId: string, key: string) => {
    setComments(prev => {
      const newComments = new Map(prev);
      const fieldComments = newComments.get(key) || [];
      const updatedComments = fieldComments.map(c => 
        c.id === commentId ? { ...c, resolved: true } : c
      );
      newComments.set(key, updatedComments);
      return newComments;
    });
  };
  
  // è·å–å­—æ®µçš„è¯„è®º
  const getFieldComments = (recordId: string, fieldId: string): Comment[] => {
    const key = `${recordId}:${fieldId}`;
    return comments.get(key) || [];
  };
  
  return {
    comments,
    addComment,
    replyComment,
    resolveComment,
    getFieldComments
  };
}
```

### 3. UI å±•ç¤ºå±‚

#### DocumentRenderer ç»„ä»¶

```typescript
/**
 * æ–‡æ¡£æ¸²æŸ“ç»„ä»¶
 */
interface DocumentRendererProps {
  records: IRecord[];
  fields: IFieldMeta[];
  changes: Map<string, FieldChange>;
  onFieldEdit: (recordId: string, fieldId: string, value: any) => void;
  onFieldComment: (recordId: string, fieldId: string) => void;
}

export function DocumentRenderer({
  records,
  fields,
  changes,
  onFieldEdit,
  onFieldComment
}: DocumentRendererProps) {
  return (
    <div className="document-container">
      <DocumentHeader />
      
      {records.map(record => (
        <div key={record.recordId} className="document-section">
          <h2 className="section-title">
            {getRecordTitle(record, fields[0])}
          </h2>
          
          <div className="field-grid">
            {fields.slice(1).map(field => (
              <FieldRenderer
                key={field.id}
                record={record}
                field={field}
                value={record.fields[field.id]}
                isChanged={changes.has(`${record.recordId}:${field.id}`)}
                onEdit={(value) => onFieldEdit(record.recordId, field.id, value)}
                onComment={() => onFieldComment(record.recordId, field.id)}
              />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```

#### FieldRenderer ç»„ä»¶

```typescript
/**
 * å­—æ®µæ¸²æŸ“å™¨
 */
interface FieldRendererProps {
  record: IRecord;
  field: IFieldMeta;
  value: any;
  isChanged: boolean;
  onEdit: (value: any) => void;
  onComment: () => void;
}

export function FieldRenderer({
  field,
  value,
  isChanged,
  onEdit,
  onComment
}: FieldRendererProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(value);
  
  const handleSave = () => {
    onEdit(editValue);
    setIsEditing(false);
  };
  
  return (
    <div className={`field-item ${isChanged ? 'changed' : ''}`}>
      <div className="field-header">
        <label className="field-label">{field.name}</label>
        <div className="field-actions">
          <Button size="small" icon={<IconComment />} onClick={onComment} />
        </div>
      </div>
      
      <div className="field-content">
        {isEditing ? (
          <FieldEditor
            type={field.type}
            value={editValue}
            onChange={setEditValue}
            onSave={handleSave}
            onCancel={() => setIsEditing(false)}
          />
        ) : (
          <div 
            className="field-display"
            onClick={() => setIsEditing(true)}
          >
            <FieldDisplay type={field.type} value={value} />
          </div>
        )}
      </div>
    </div>
  );
}
```

## æ•°æ®æµè®¾è®¡

### è¯»å–æµç¨‹

```
ç”¨æˆ·æ‰“å¼€æ’ä»¶
    â†“
é€‰æ‹©è¡¨æ ¼å’Œè®°å½•
    â†“
useTableData åŠ è½½æ•°æ®
    â†“
DocumentRenderer æ¸²æŸ“
    â†“
ç”¨æˆ·æŸ¥çœ‹æ–‡æ¡£
```

### ç¼–è¾‘æµç¨‹

```
ç”¨æˆ·ç‚¹å‡»å­—æ®µè¿›å…¥ç¼–è¾‘
    â†“
ä¿®æ”¹å­—æ®µå€¼
    â†“
useChangeTracking è®°å½•å˜æ›´
    â†“
é«˜äº®æ˜¾ç¤ºå·²ä¿®æ”¹å­—æ®µ
    â†“
è‡ªåŠ¨ä¿å­˜è‰ç¨¿åˆ°æœ¬åœ°
```

### åŒæ­¥æµç¨‹

```
ç”¨æˆ·ç‚¹å‡»"åŒæ­¥"æŒ‰é’®
    â†“
æ˜¾ç¤ºå¾…åŒæ­¥å˜æ›´åˆ—è¡¨
    â†“
ç”¨æˆ·ç¡®è®¤
    â†“
useDocumentSync æ‰¹é‡æ›´æ–°
    â†“
æ›´æ–°æˆåŠŸ/å¤±è´¥åé¦ˆ
    â†“
æ¸…é™¤å·²åŒæ­¥çš„å˜æ›´è®°å½•
```

### è¯„è®ºæµç¨‹

```
ç”¨æˆ·ç‚¹å‡»è¯„è®ºæŒ‰é’®
    â†“
æ‰“å¼€è¯„è®ºé¢æ¿
    â†“
è¾“å…¥è¯„è®ºå†…å®¹
    â†“
useCommentSystem ä¿å­˜è¯„è®º
    â†“
æ˜¾ç¤ºè¯„è®ºå¾½ç« 
    â†“
å…¶ä»–ç”¨æˆ·å¯è§è¯„è®º
```

## æŠ€æœ¯é€‰å‹

### å¯Œæ–‡æœ¬ç¼–è¾‘å™¨å¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|------|------|------|--------|
| **Quill** | è½»é‡ã€APIç®€æ´ã€ä¸­æ–‡æ–‡æ¡£å¥½ | æ‰©å±•æ€§ä¸€èˆ¬ | â­â­â­â­â­ |
| **Slate** | é«˜åº¦å¯å®šåˆ¶ã€Reactå‹å¥½ | å­¦ä¹ æ›²çº¿é™¡å³­ | â­â­â­â­ |
| **TinyMCE** | åŠŸèƒ½å¼ºå¤§ã€æˆç†Ÿç¨³å®š | ä½“ç§¯å¤§ã€é…ç½®å¤æ‚ | â­â­â­ |
| **ProseMirror** | æ€§èƒ½å¥½ã€æ¶æ„ä¼˜é›… | ä¸Šæ‰‹éš¾åº¦å¤§ | â­â­â­ |

**æœ€ç»ˆé€‰æ‹©**: **Quill** - é€‚åˆ MVP å¿«é€Ÿå¼€å‘ï¼Œåç»­å¯è¿ç§»åˆ° Slate

### çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ

ç”±äºåº”ç”¨è§„æ¨¡é€‚ä¸­ï¼Œé‡‡ç”¨ **React Hooks + Context** å³å¯ï¼Œæ— éœ€å¼•å…¥ Redux/Zustand

```typescript
// å…¨å±€çŠ¶æ€ç®¡ç†
export const AppContext = createContext<AppState | null>(null);

export function AppProvider({ children }: { children: React.ReactNode }) {
  const tableData = useTableData();
  const changeTracking = useChangeTracking();
  const commentSystem = useCommentSystem();
  const documentSync = useDocumentSync();
  
  const value = {
    ...tableData,
    ...changeTracking,
    ...commentSystem,
    ...documentSync
  };
  
  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
}
```

## å…³é”®æŠ€æœ¯å®ç°

### 1. å­—æ®µå€¼æ ¼å¼åŒ–

```typescript
/**
 * æ ¹æ®å­—æ®µç±»å‹æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
 */
export function formatFieldValue(value: any, fieldType: FieldType): string {
  switch (fieldType) {
    case FieldType.Text:
    case FieldType.Barcode:
    case FieldType.Email:
    case FieldType.Phone:
    case FieldType.Url:
      return String(value || '');
      
    case FieldType.Number:
    case FieldType.Currency:
    case FieldType.Percent:
      return formatNumber(value, fieldType);
      
    case FieldType.DateTime:
      return formatDate(value);
      
    case FieldType.SingleSelect:
      return value?.text || '';
      
    case FieldType.MultiSelect:
      return Array.isArray(value) 
        ? value.map(v => v.text).join(', ')
        : '';
      
    case FieldType.Checkbox:
      return value ? 'âœ“' : '';
      
    case FieldType.User:
      return Array.isArray(value)
        ? value.map(u => u.name).join(', ')
        : value?.name || '';
      
    default:
      return String(value || '');
  }
}
```

### 2. è‰ç¨¿è‡ªåŠ¨ä¿å­˜

```typescript
/**
 * è‰ç¨¿ç®¡ç†
 */
const DRAFT_KEY_PREFIX = 'base-doc-editor:draft:';

export function saveDraft(key: string, data: any) {
  try {
    const draftKey = `${DRAFT_KEY_PREFIX}${key}`;
    localStorage.setItem(draftKey, JSON.stringify({
      data,
      timestamp: Date.now()
    }));
  } catch (error) {
    console.warn('ä¿å­˜è‰ç¨¿å¤±è´¥:', error);
  }
}

export function loadDraft(key: string): any | null {
  try {
    const draftKey = `${DRAFT_KEY_PREFIX}${key}`;
    const stored = localStorage.getItem(draftKey);
    if (!stored) return null;
    
    const { data, timestamp } = JSON.parse(stored);
    
    // è‰ç¨¿ä¿ç•™7å¤©
    if (Date.now() - timestamp > 7 * 24 * 60 * 60 * 1000) {
      localStorage.removeItem(draftKey);
      return null;
    }
    
    return data;
  } catch (error) {
    console.warn('åŠ è½½è‰ç¨¿å¤±è´¥:', error);
    return null;
  }
}
```

### 3. å†²çªæ£€æµ‹

```typescript
/**
 * åŒæ­¥å‰æ£€æµ‹æ˜¯å¦æœ‰å†²çª
 */
export async function detectConflicts(
  tableId: string,
  changes: FieldChange[]
): Promise<ConflictInfo[]> {
  const conflicts: ConflictInfo[] = [];
  const table = await bitable.base.getTable(tableId);
  
  for (const change of changes) {
    // è·å–å½“å‰è¡¨æ ¼ä¸­çš„æœ€æ–°å€¼
    const currentValue = await table.getCellValue(
      change.fieldId,
      change.recordId
    );
    
    // å¦‚æœå½“å‰å€¼ä¸ç­‰äºä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜æœ‰å…¶ä»–äººä¹Ÿä¿®æ”¹äº†
    if (!isEqual(currentValue, change.oldValue)) {
      conflicts.push({
        recordId: change.recordId,
        fieldId: change.fieldId,
        ourValue: change.newValue,
        theirValue: currentValue,
        baseValue: change.oldValue
      });
    }
  }
  
  return conflicts;
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. è™šæ‹Ÿæ»šåŠ¨

å¯¹äºå¤§é‡è®°å½•ï¼Œä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨å‡å°‘ DOM èŠ‚ç‚¹ï¼š

```typescript
import { FixedSizeList } from 'react-window';

export function VirtualDocumentList({ records, fields }: Props) {
  const Row = ({ index, style }: any) => (
    <div style={style}>
      <DocumentSection record={records[index]} fields={fields} />
    </div>
  );
  
  return (
    <FixedSizeList
      height={window.innerHeight}
      itemCount={records.length}
      itemSize={400}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

### 2. é˜²æŠ–ä¼˜åŒ–

ç¼–è¾‘æ—¶ä½¿ç”¨é˜²æŠ–å‡å°‘çŠ¶æ€æ›´æ–°ï¼š

```typescript
import { useDebouncedCallback } from 'use-debounce';

export function FieldEditor({ value, onChange }: Props) {
  const debouncedChange = useDebouncedCallback(
    (newValue) => onChange(newValue),
    500
  );
  
  return (
    <input
      defaultValue={value}
      onChange={(e) => debouncedChange(e.target.value)}
    />
  );
}
```

### 3. æ‰¹é‡æ“ä½œ

åŒæ­¥æ—¶ä½¿ç”¨æ‰¹é‡æ¥å£ï¼š

```typescript
// âœ… æ¨èï¼šæ‰¹é‡æ›´æ–°
await table.setRecords([
  { recordId: 'rec1', fields: { fld1: 'value1' } },
  { recordId: 'rec2', fields: { fld2: 'value2' } }
]);

// âŒ ä¸æ¨èï¼šå¾ªç¯å•æ¬¡æ›´æ–°
for (const record of records) {
  await table.setCellValue(fieldId, record.recordId, value);
}
```

## å®‰å…¨æ–¹æ¡ˆ

### 1. æƒé™æ§åˆ¶

```typescript
/**
 * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ç¼–è¾‘æƒé™
 */
export async function checkEditPermission(tableId: string): Promise<boolean> {
  try {
    const table = await bitable.base.getTable(tableId);
    const permission = await table.checkPermission({
      type: 'record',
      operation: 'update'
    });
    return permission.status;
  } catch (error) {
    return false;
  }
}
```

### 2. æ•°æ®åŠ å¯†

è¯„è®ºæ•°æ®å­˜å‚¨æ—¶åŠ å¯†ï¼š

```typescript
import CryptoJS from 'crypto-js';

const ENCRYPT_KEY = 'base-doc-editor-secret';

export function encryptData(data: any): string {
  return CryptoJS.AES.encrypt(
    JSON.stringify(data),
    ENCRYPT_KEY
  ).toString();
}

export function decryptData(encrypted: string): any {
  const bytes = CryptoJS.AES.decrypt(encrypted, ENCRYPT_KEY);
  return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
}
```

### 3. XSS é˜²æŠ¤

æ¸²æŸ“ç”¨æˆ·è¾“å…¥æ—¶è¿›è¡Œè½¬ä¹‰ï¼š

```typescript
import DOMPurify from 'dompurify';

export function sanitizeHTML(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'u', 'strong', 'em', 'p', 'br'],
    ALLOWED_ATTR: []
  });
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-11-23  
**æœ€åæ›´æ–°**: 2025-11-23

